# -*- coding: utf-8 -*-
"""shift.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tG_do7mHn922lQmxkFSiwZdMaUpNTazK
"""

import streamlit as st
import numpy as np
import matplotlib.pyplot as plt

# Display Company Logo and App Title
st.image("shift.jpg", use_column_width=True)
st.title("Automotive Coating Wear Rate Simulator")
st.subheader("A Multi-Model Approach to Analyze Wear in Coatings")

# Sidebar for User Inputs
st.sidebar.header("Input Parameters")

# Input Parameters
load = st.sidebar.number_input("Applied Load (N)", value=500)
sliding_distance = st.sidebar.number_input("Sliding Distance (m)", value=1000)
hardness = st.sidebar.number_input("Material Hardness (Pa)", value=2e9)
contact_radius = st.sidebar.number_input("Contact Area Radius (mm)", value=2.0) / 1000  # in meters
impact_energy = st.sidebar.number_input("Impact Energy (J)", value=10)
strain_energy = st.sidebar.number_input("Strain Energy (J)", value=5)
velocity = st.sidebar.slider("Velocity (m/s)", 1, 100, 20)
friction_force = st.sidebar.number_input("Friction Force (N)", value=300)
number_of_cycles = st.sidebar.number_input("Number of Cycles", value=1000)

# Archard's Wear Model
def archard_wear(load, distance, hardness):
    wear_volume = (load * distance) / hardness
    return wear_volume

# Hertzian Contact Model
def hertz_wear(load, radius):
    pressure = (3 * load) / (2 * np.pi * radius ** 2)
    return pressure

# Energy-Based Wear Model
def energy_wear(impact_energy, hardness):
    wear_rate = (impact_energy) / hardness
    return wear_rate

# Frictional Energy Model
def friction_wear(friction_force, velocity, hardness):
    work_done = friction_force * velocity
    wear_volume = work_done / hardness
    return wear_volume

# Delamination Wear Model
def delamination_wear(number_of_cycles):
    wear_volume = number_of_cycles ** 0.5  # Simplified wear rate model
    return wear_volume

# Thickness Reduction Model
def thickness_wear(thickness_loss, time):
    wear_rate = thickness_loss / time
    return wear_rate

# Simulation Results
st.header("Simulation Results")

# Archard's Wear Model
archard_result = archard_wear(load, sliding_distance, hardness)
st.subheader("Archard's Wear Model")
st.write(f"Wear Volume: {archard_result:.2e} m^3")

# Hertzian Contact Model
hertz_result = hertz_wear(load, contact_radius)
st.subheader("Hertzian Contact Model")
st.write(f"Contact Pressure: {hertz_result:.2e} Pa")

# Energy-Based Wear Model
energy_wear_result = energy_wear(impact_energy, hardness)
st.subheader("Energy-Based Wear Model")
st.write(f"Wear Rate (Energy-Based): {energy_wear_result:.2e} m^3/J")

# Frictional Energy Wear Model
friction_wear_result = friction_wear(friction_force, velocity, hardness)
st.subheader("Frictional Energy Model")
st.write(f"Wear Volume (Friction-Based): {friction_wear_result:.2e} m^3")

# Delamination Wear Model
delamination_wear_result = delamination_wear(number_of_cycles)
st.subheader("Delamination Wear Model")
st.write(f"Wear Volume (Delamination-Based): {delamination_wear_result:.2e} m^3")

# Plot Results
fig, ax = plt.subplots()
ax.bar(["Archard", "Hertz", "Energy-Based", "Friction-Based", "Delamination"],
       [archard_result, hertz_result, energy_wear_result, friction_wear_result, delamination_wear_result])
ax.set_ylabel('Wear Volume / Pressure (Pa)')
ax.set_title('Comparison of Wear Models')
st.pyplot(fig)